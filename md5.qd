/// MD5 Implementation
/// ==================
///
/// MD5 hash with streaming and one-shot APIs.
/// Note: MD5 is cryptographically broken. Use only for checksums, not security.
///
/// @example
/// use crypto
///
/// // One-shot
/// "Hello" md5! -> hash
///
/// // Streaming
/// Md5 {} -> h
/// h "Hello" update! -> h
/// h " World" update! -> h
/// h finish! -> hash
/// h release

use bits
use mem
use str

// MD5 initial hash values (little-endian)
const MD5_A = 1732584193
const MD5_B = 4023233417
const MD5_C = 2562383102
const MD5_D = 271733878

/// MD5 hasher state for streaming computation.
pub struct Md5 {
	a:i64 = 1732584193
	b:i64 = 4023233417
	c:i64 = 2562383102
	d:i64 = 271733878
	buf:ptr = 0
	buflen:i64 = 0
	total:i64 = 0
}

// MD5 per-round shift amounts
fn md5_make_s( -- s:ptr) {
	64 mem::alloc! -> s
	// Round 1
	7 s 0 mem::set_byte   12 s 1 mem::set_byte   17 s 2 mem::set_byte   22 s 3 mem::set_byte
	7 s 4 mem::set_byte   12 s 5 mem::set_byte   17 s 6 mem::set_byte   22 s 7 mem::set_byte
	7 s 8 mem::set_byte   12 s 9 mem::set_byte   17 s 10 mem::set_byte  22 s 11 mem::set_byte
	7 s 12 mem::set_byte  12 s 13 mem::set_byte  17 s 14 mem::set_byte  22 s 15 mem::set_byte
	// Round 2
	5 s 16 mem::set_byte  9 s 17 mem::set_byte   14 s 18 mem::set_byte  20 s 19 mem::set_byte
	5 s 20 mem::set_byte  9 s 21 mem::set_byte   14 s 22 mem::set_byte  20 s 23 mem::set_byte
	5 s 24 mem::set_byte  9 s 25 mem::set_byte   14 s 26 mem::set_byte  20 s 27 mem::set_byte
	5 s 28 mem::set_byte  9 s 29 mem::set_byte   14 s 30 mem::set_byte  20 s 31 mem::set_byte
	// Round 3
	4 s 32 mem::set_byte  11 s 33 mem::set_byte  16 s 34 mem::set_byte  23 s 35 mem::set_byte
	4 s 36 mem::set_byte  11 s 37 mem::set_byte  16 s 38 mem::set_byte  23 s 39 mem::set_byte
	4 s 40 mem::set_byte  11 s 41 mem::set_byte  16 s 42 mem::set_byte  23 s 43 mem::set_byte
	4 s 44 mem::set_byte  11 s 45 mem::set_byte  16 s 46 mem::set_byte  23 s 47 mem::set_byte
	// Round 4
	6 s 48 mem::set_byte  10 s 49 mem::set_byte  15 s 50 mem::set_byte  21 s 51 mem::set_byte
	6 s 52 mem::set_byte  10 s 53 mem::set_byte  15 s 54 mem::set_byte  21 s 55 mem::set_byte
	6 s 56 mem::set_byte  10 s 57 mem::set_byte  15 s 58 mem::set_byte  21 s 59 mem::set_byte
	6 s 60 mem::set_byte  10 s 61 mem::set_byte  15 s 62 mem::set_byte  21 s 63 mem::set_byte
	s
}

// MD5 round constants K[i] = floor(2^32 * abs(sin(i+1)))
fn md5_make_k( -- k:ptr) {
	512 mem::alloc! -> k
	3614090360 k 0 mem::set_i64
	3905402710 k 8 mem::set_i64
	606105819 k 16 mem::set_i64
	3250441966 k 24 mem::set_i64
	4118548399 k 32 mem::set_i64
	1200080426 k 40 mem::set_i64
	2821735955 k 48 mem::set_i64
	4249261313 k 56 mem::set_i64
	1770035416 k 64 mem::set_i64
	2336552879 k 72 mem::set_i64
	4294925233 k 80 mem::set_i64
	2304563134 k 88 mem::set_i64
	1804603682 k 96 mem::set_i64
	4254626195 k 104 mem::set_i64
	2792965006 k 112 mem::set_i64
	1236535329 k 120 mem::set_i64
	4129170786 k 128 mem::set_i64
	3225465664 k 136 mem::set_i64
	643717713 k 144 mem::set_i64
	3921069994 k 152 mem::set_i64
	3593408605 k 160 mem::set_i64
	38016083 k 168 mem::set_i64
	3634488961 k 176 mem::set_i64
	3889429448 k 184 mem::set_i64
	568446438 k 192 mem::set_i64
	3275163606 k 200 mem::set_i64
	4107603335 k 208 mem::set_i64
	1163531501 k 216 mem::set_i64
	2850285829 k 224 mem::set_i64
	4243563512 k 232 mem::set_i64
	1735328473 k 240 mem::set_i64
	2368359562 k 248 mem::set_i64
	4294588738 k 256 mem::set_i64
	2272392833 k 264 mem::set_i64
	1839030562 k 272 mem::set_i64
	4259657740 k 280 mem::set_i64
	2763975236 k 288 mem::set_i64
	1272893353 k 296 mem::set_i64
	4139469664 k 304 mem::set_i64
	3200236656 k 312 mem::set_i64
	681279174 k 320 mem::set_i64
	3936430074 k 328 mem::set_i64
	3572445317 k 336 mem::set_i64
	76029189 k 344 mem::set_i64
	3654602809 k 352 mem::set_i64
	3873151461 k 360 mem::set_i64
	530742520 k 368 mem::set_i64
	3299628645 k 376 mem::set_i64
	4096336452 k 384 mem::set_i64
	1126891415 k 392 mem::set_i64
	2878612391 k 400 mem::set_i64
	4237533241 k 408 mem::set_i64
	1700485571 k 416 mem::set_i64
	2399980690 k 424 mem::set_i64
	4293915773 k 432 mem::set_i64
	2240044497 k 440 mem::set_i64
	1873313359 k 448 mem::set_i64
	4264355552 k 456 mem::set_i64
	2734768916 k 464 mem::set_i64
	1309151649 k 472 mem::set_i64
	4149444226 k 480 mem::set_i64
	3174756917 k 488 mem::set_i64
	718787259 k 496 mem::set_i64
	3951481745 k 504 mem::set_i64
	k
}

fn md5_rotl32(x:i64 n:i64 -- result:i64) {
	-> n -> x
	x 32 bits::mask -> x
	x n shl x 32 n - shr or 32 bits::mask
}

// Read 32-bit little-endian from buffer
fn md5_read_u32_le(buf:ptr offset:i64 -- val:i64) {
	-> offset -> buf
	buf offset mem::get_byte
	buf offset 1 + mem::get_byte 8 shl or
	buf offset 2 + mem::get_byte 16 shl or
	buf offset 3 + mem::get_byte 24 shl or
}

// Write 32-bit little-endian to buffer
fn md5_write_u32_le(buf:ptr offset:i64 val:i64 -- ) {
	-> val -> offset -> buf
	val 255 and buf offset mem::set_byte
	val 8 shr 255 and buf offset 1 + mem::set_byte
	val 16 shr 255 and buf offset 2 + mem::set_byte
	val 24 shr 255 and buf offset 3 + mem::set_byte
}

// Process a single 64-byte block
fn md5_process_block(aa:i64 bb:i64 cc:i64 dd:i64 block:ptr -- ra:i64 rb:i64 rc:i64 rd:i64) {
	-> block
	-> dd -> cc -> bb -> aa

	md5_make_k -> k
	md5_make_s -> s

	// Load message into M[0..15]
	128 mem::alloc! -> m
	0 16 1 for i {
		block i 4 * md5_read_u32_le m i 8 * mem::set_i64
	}

	aa -> a
	bb -> b
	cc -> c
	dd -> d

	// 64 rounds
	0 64 1 for i {
		0 -> f
		0 -> g

		// Round 1: i < 16
		i 16 < if {
			b c and b not d and or 32 bits::mask -> f
			i -> g
		}
		// Round 2: 16 <= i < 32
		i 16 >= i 32 < and if {
			d b and d not c and or 32 bits::mask -> f
			5 i * 1 + 16 mod -> g
		}
		// Round 3: 32 <= i < 48
		i 32 >= i 48 < and if {
			b c xor d xor 32 bits::mask -> f
			3 i * 5 + 16 mod -> g
		}
		// Round 4: i >= 48
		i 48 >= if {
			c b d not or xor 32 bits::mask -> f
			7 i * 16 mod -> g
		}

		f a + k i 8 * mem::get_i64 + m g 8 * mem::get_i64 + 32 bits::mask -> f
		d -> d_tmp
		c -> d
		b -> c
		f s i mem::get_byte md5_rotl32 b + 32 bits::mask -> b
		d_tmp -> a
	}

	m mem::free
	s mem::free
	k mem::free

	aa a + 32 bits::mask
	bb b + 32 bits::mask
	cc c + 32 bits::mask
	dd d + 32 bits::mask
}

/// Update MD5 state with additional data.
/// @param h Md5 The hasher state
/// @param data str Data to hash
/// @return h2 Md5 Updated hasher state
pub fn (h:Md5) update(data:str -- h2:Md5)! {
	-> data

	h @a -> aa
	h @b -> bb
	h @c -> cc
	h @d -> dd
	h @buf -> buf
	h @buflen -> buflen
	h @total -> total

	// Lazy init buffer
	buf 0 == if {
		64 mem::alloc! -> buf
	}

	data str::len -> dlen
	total dlen + -> total

	0 -> i
	loop {
		i dlen >= if { break }

		// Fill buffer
		loop {
			buflen 64 >= if { break }
			i dlen >= if { break }
			data i str::char_at! buf buflen mem::set_byte
			buflen 1 + -> buflen
			i 1 + -> i
		}

		// Process complete block
		buflen 64 == if {
			aa bb cc dd buf md5_process_block -> dd -> cc -> bb -> aa
			0 -> buflen
		}
	}

	Md5 {
		a = aa b = bb c = cc d = dd
		buf = buf buflen = buflen total = total
	}
}

/// Finalize MD5 and get result as hex string.
/// @param h Md5 The hasher state
/// @return hash str 32-character hex string (lowercase)
pub fn (h:Md5) finish( -- hash:str)! {
	h @a -> aa
	h @b -> bb
	h @c -> cc
	h @d -> dd
	h @buf -> buf
	h @buflen -> buflen
	h @total -> total

	buf 0 == if {
		64 mem::alloc! -> buf
	}

	// Pad message
	128 buf buflen mem::set_byte
	buflen 1 + -> buflen

	// If not enough room for length (8 bytes), pad and process
	buflen 56 > if {
		loop {
			buflen 64 >= if { break }
			0 buf buflen mem::set_byte
			buflen 1 + -> buflen
		}
		aa bb cc dd buf md5_process_block -> dd -> cc -> bb -> aa
		0 -> buflen
	}

	// Pad to 56 bytes
	loop {
		buflen 56 >= if { break }
		0 buf buflen mem::set_byte
		buflen 1 + -> buflen
	}

	// Append length in bits (little-endian, 64-bit)
	total 8 * -> bitlen
	bitlen 32 shr -> bitlen_hi
	buf 56 bitlen md5_write_u32_le
	buf 60 bitlen_hi md5_write_u32_le

	aa bb cc dd buf md5_process_block -> dd -> cc -> bb -> aa

	// Convert to hex (32 chars for 128 bits)
	// Output is A, B, C, D in little-endian byte order
	32 mem::alloc! -> out
	0 -> pos

	// Write A (little-endian bytes)
	0 4 1 for j {
		aa j 8 * shr 255 and -> byte
		byte 4 shr -> hi
		byte 15 and -> lo
		hi 10 < if { 48 hi + } else { 87 hi + } out pos mem::set_byte
		pos 1 + -> pos
		lo 10 < if { 48 lo + } else { 87 lo + } out pos mem::set_byte
		pos 1 + -> pos
	}

	// Write B
	0 4 1 for j {
		bb j 8 * shr 255 and -> byte
		byte 4 shr -> hi
		byte 15 and -> lo
		hi 10 < if { 48 hi + } else { 87 hi + } out pos mem::set_byte
		pos 1 + -> pos
		lo 10 < if { 48 lo + } else { 87 lo + } out pos mem::set_byte
		pos 1 + -> pos
	}

	// Write C
	0 4 1 for j {
		cc j 8 * shr 255 and -> byte
		byte 4 shr -> hi
		byte 15 and -> lo
		hi 10 < if { 48 hi + } else { 87 hi + } out pos mem::set_byte
		pos 1 + -> pos
		lo 10 < if { 48 lo + } else { 87 lo + } out pos mem::set_byte
		pos 1 + -> pos
	}

	// Write D
	0 4 1 for j {
		dd j 8 * shr 255 and -> byte
		byte 4 shr -> hi
		byte 15 and -> lo
		hi 10 < if { 48 hi + } else { 87 hi + } out pos mem::set_byte
		pos 1 + -> pos
		lo 10 < if { 48 lo + } else { 87 lo + } out pos mem::set_byte
		pos 1 + -> pos
	}

	out 32 mem::to_string -> result
	out mem::free
	result
}

/// Free resources used by MD5 hasher.
/// @param h Md5 The hasher state to free
pub fn (h:Md5) release( -- ) {
	h @buf -> buf
	buf 0 != if {
		buf mem::free
	}
}

/// One-shot MD5 of a string.
/// Note: MD5 is cryptographically broken. Use only for checksums, not security.
/// @param s str Input string
/// @return hash str 32-character hex string
/// @example "Hello" md5! -> hash
pub fn md5(s:str -- hash:str)! {
	-> s
	Md5 {} -> h
	h s update! -> h
	h finish! -> result
	h release
	result
}
